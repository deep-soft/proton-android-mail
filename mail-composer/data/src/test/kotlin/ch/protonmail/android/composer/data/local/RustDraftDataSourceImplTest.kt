package ch.protonmail.android.composer.data.local

import arrow.core.left
import arrow.core.right
import ch.protonmail.android.composer.data.local.RustDraftDataSourceImpl.Companion.InitialDelayForSendingStatusWorker
import ch.protonmail.android.composer.data.mapper.toSingleRecipientEntry
import ch.protonmail.android.composer.data.usecase.CreateRustDraft
import ch.protonmail.android.composer.data.usecase.DiscardRustDraft
import ch.protonmail.android.composer.data.usecase.OpenRustDraft
import ch.protonmail.android.composer.data.usecase.RustDraftUndoSend
import ch.protonmail.android.composer.data.worker.SendingStatusWorker
import ch.protonmail.android.composer.data.wrapper.ComposerRecipientListWrapper
import ch.protonmail.android.composer.data.wrapper.DraftWrapper
import ch.protonmail.android.mailcommon.data.mapper.LocalMessageId
import ch.protonmail.android.mailcommon.data.worker.Enqueuer
import ch.protonmail.android.mailcommon.domain.model.DataError
import ch.protonmail.android.mailcommon.domain.sample.UserIdSample
import ch.protonmail.android.mailcomposer.domain.model.DraftBody
import ch.protonmail.android.mailcomposer.domain.model.Subject
import ch.protonmail.android.mailmessage.data.mapper.toLocalMessageId
import ch.protonmail.android.mailmessage.data.mapper.toMessageId
import ch.protonmail.android.mailmessage.domain.model.DraftAction
import ch.protonmail.android.mailmessage.domain.model.MessageId
import ch.protonmail.android.mailmessage.domain.sample.MessageIdSample
import ch.protonmail.android.mailmessage.domain.sample.RecipientSample
import ch.protonmail.android.mailsession.domain.repository.UserSessionRepository
import ch.protonmail.android.mailsession.domain.wrapper.MailUserSessionWrapper
import ch.protonmail.android.testdata.composer.LocalComposerRecipientTestData
import ch.protonmail.android.testdata.composer.LocalDraftTestData
import ch.protonmail.android.testdata.message.rust.LocalMessageIdSample
import io.mockk.Runs
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.just
import io.mockk.mockk
import io.mockk.verifyOrder
import junit.framework.TestCase.assertNull
import kotlinx.coroutines.flow.flowOf
import kotlinx.coroutines.test.runTest
import uniffi.proton_mail_uniffi.DraftCreateMode
import uniffi.proton_mail_uniffi.DraftMessageIdResult
import uniffi.proton_mail_uniffi.DraftSaveSendError
import uniffi.proton_mail_uniffi.DraftSaveSendErrorReason
import uniffi.proton_mail_uniffi.VoidDraftSaveSendResult
import kotlin.test.Test
import kotlin.test.assertEquals

class RustDraftDataSourceImplTest {

    private val userSessionRepository = mockk<UserSessionRepository>()
    private val createRustDraft = mockk<CreateRustDraft>()
    private val openRustDraft = mockk<OpenRustDraft>()
    private val discardRustDraft = mockk<DiscardRustDraft>()

    private val mockUserSession = mockk<MailUserSessionWrapper>()
    private val enqueuer = mockk<Enqueuer>()
    private val rustDraftUndoSend = mockk<RustDraftUndoSend>()

    private val dataSource = RustDraftDataSourceImpl(
        userSessionRepository,
        createRustDraft,
        openRustDraft,
        discardRustDraft,
        rustDraftUndoSend,
        enqueuer
    )

    @Test
    fun `open draft returns error when there is no user session`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.PlainTextMessage
        val expected = DataError.Local.Unknown
        coEvery { userSessionRepository.getUserSession(userId) } returns null

        // When
        val actual = dataSource.open(userId, messageId)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `open draft returns Local Draft data when opened successfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        val localMessageId = MessageIdSample.RustJobApplication.toLocalMessageId()
        val expected = LocalDraftTestData.JobApplicationDraftWithRecipients
        val toRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val ccRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val bccRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            expected.subject,
            expected.sender,
            expected.body,
            toRecipientsWrapperMock,
            ccRecipientsWrapperMock,
            bccRecipientsWrapperMock,
            localMessageId
        )
        coEvery { toRecipientsWrapperMock.recipients() } returns listOf(LocalComposerRecipientTestData.Alice)
        coEvery { ccRecipientsWrapperMock.recipients() } returns listOf(LocalComposerRecipientTestData.Bob)
        coEvery { bccRecipientsWrapperMock.recipients() } returns listOf(
            LocalComposerRecipientTestData.Billing, LocalComposerRecipientTestData.Doe
        )
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { openRustDraft(mockUserSession, localMessageId) } returns expectedDraftWrapper.right()

        // When
        val actual = dataSource.open(userId, messageId)

        // Then
        assertEquals(actual, expected.right())
    }

    @Test
    fun `data source holds instance of the draft when opened successfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        val localMessageId = MessageIdSample.RustJobApplication.toLocalMessageId()
        val expected = LocalDraftTestData.JobApplicationDraft
        val recipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            expected.subject,
            expected.sender,
            expected.body,
            recipientsWrapperMock,
            recipientsWrapperMock,
            recipientsWrapperMock
        )
        coEvery { recipientsWrapperMock.recipients() } returns emptyList()
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { openRustDraft(mockUserSession, localMessageId) } returns expectedDraftWrapper.right()
        assertNull(dataSource.draftWrapperMutableStateFlow.value)

        // When
        dataSource.open(userId, messageId)

        // Then
        assertEquals(dataSource.draftWrapperMutableStateFlow.value, expectedDraftWrapper)
    }

    @Test
    fun `create draft returns error when there is no user session`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.PlainTextMessage
        val action = DraftAction.Reply(messageId)
        val expected = DataError.Local.Unknown
        coEvery { userSessionRepository.getUserSession(userId) } returns null

        // When
        val actual = dataSource.create(userId, action)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `create draft returns error when draft create mode is not supported`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val action = DraftAction.ComposeToAddresses(emptyList())
        val expected = DataError.Local.UnsupportedOperation
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession

        // When
        val actual = dataSource.create(userId, action)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `create draft returns Local Draft data when created successfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        val action = DraftAction.ReplyAll(messageId)
        val localDraftCreateMode = DraftCreateMode.ReplyAll(messageId.toLocalMessageId())
        val expected = LocalDraftTestData.JobApplicationDraft
        val subject = expected.subject
        val sender = expected.sender
        val body = expected.body
        val recipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            subject,
            sender,
            body,
            recipientsWrapperMock,
            recipientsWrapperMock,
            recipientsWrapperMock,
            messageId.toLocalMessageId()
        )
        coEvery { recipientsWrapperMock.recipients() } returns emptyList()
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { createRustDraft(mockUserSession, localDraftCreateMode) } returns expectedDraftWrapper.right()

        // When
        val actual = dataSource.create(userId, action)

        // Then
        assertEquals(actual, expected.right())
    }

    @Test
    fun `data source holds instance of the draft when created successfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        val action = DraftAction.Forward(messageId)
        val localDraftCreateMode = DraftCreateMode.Forward(messageId.toLocalMessageId())
        val expected = LocalDraftTestData.JobApplicationDraft
        val recipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            expected.subject,
            expected.sender,
            expected.body,
            recipientsWrapperMock,
            recipientsWrapperMock,
            recipientsWrapperMock
        )
        coEvery { recipientsWrapperMock.recipients() } returns emptyList()
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { createRustDraft(mockUserSession, localDraftCreateMode) } returns expectedDraftWrapper.right()
        assertNull(dataSource.draftWrapperMutableStateFlow.value)

        // When
        dataSource.create(userId, action)

        // Then
        assertEquals(dataSource.draftWrapperMutableStateFlow.value, expectedDraftWrapper)
    }

    @Test
    fun `discard draft returns error when there is no user session`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.PlainTextMessage
        val expected = DataError.Local.Unknown
        coEvery { userSessionRepository.getUserSession(userId) } returns null

        // When
        val actual = dataSource.discard(userId, messageId)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `discard draft returns Unit when discarding successfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { discardRustDraft(mockUserSession, messageId.toLocalMessageId()) } returns Unit.right()

        // When
        val actual = dataSource.discard(userId, messageId)

        // Then
        assertEquals(actual, Unit.right())
    }

    @Test
    fun `discard draft returns DataError when discarding unsuccessfully`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.RustJobApplication
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery {
            discardRustDraft(mockUserSession, messageId.toLocalMessageId())
        } returns DataError.Local.Unknown.left()

        // When
        val actual = dataSource.discard(userId, messageId)

        // Then
        assertEquals(actual, DataError.Local.Unknown.left())
    }

    @Test
    fun `save draft returns error when no draft instance exists`() = runTest {
        // Given
        val expected = DataError.Local.SaveDraftError.NoRustDraftAvailable

        // When
        val actual = dataSource.save()

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `save draft calls rust draft wrapper when draft instance exists`() = runTest {
        // Given
        val messageId = MessageIdSample.RustJobApplication
        val draft = LocalDraftTestData.JobApplicationDraft
        val expectedDraftWrapper = expectDraftWrapperReturns(
            draft.subject,
            draft.sender,
            draft.body,
            messageId = messageId.toLocalMessageId()
        )
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.save() } returns VoidDraftSaveSendResult.Ok

        // When
        val actual = dataSource.save()

        // Then
        assertEquals(actual, Unit.right())
    }

    @Test
    fun `save draft returns error when rust draft wrapper call fails`() = runTest {
        // Given
        val draft = LocalDraftTestData.JobApplicationDraft
        val expectedDraftWrapper = expectDraftWrapperReturns(draft.subject, draft.sender, draft.body)
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.save() } returns VoidDraftSaveSendResult.Error(
            DraftSaveSendError.Reason(DraftSaveSendErrorReason.NoRecipients)
        )
        val expected = DataError.Local.SendDraftError.InvalidRecipient

        // When
        val actual = dataSource.save()

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `save subject calls rust draft wrapper to set subject and save`() = runTest {
        // Given
        val messageId = MessageIdSample.RustJobApplication
        val draft = LocalDraftTestData.JobApplicationDraft
        val subject = Subject("saving a draft...")
        val expectedDraftWrapper = expectDraftWrapperReturns(
            draft.subject,
            draft.sender,
            draft.body,
            messageId = messageId.toLocalMessageId()
        )
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.setSubject(subject.value) } returns VoidDraftSaveSendResult.Ok
        coEvery { expectedDraftWrapper.save() } returns VoidDraftSaveSendResult.Ok

        // When
        val actual = dataSource.saveSubject(subject)

        // Then
        assertEquals(actual, Unit.right())
    }

    @Test
    fun `save subject returns error when rust draft wrapper call fails`() = runTest {
        // Given
        val draft = LocalDraftTestData.JobApplicationDraft
        val expectedDraftWrapper = expectDraftWrapperReturns(draft.subject, draft.sender, draft.body)
        val subject = Subject("saving a draft...")
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.setSubject(subject.value) } returns VoidDraftSaveSendResult.Error(
            DraftSaveSendError.Reason(DraftSaveSendErrorReason.MessageIsNotADraft)
        )
        val expected = DataError.Local.SendDraftError.AlreadySent

        // When
        val actual = dataSource.saveSubject(subject)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `save body calls rust draft wrapper to set body and save`() = runTest {
        // Given
        val messageId = MessageIdSample.RustJobApplication
        val draft = LocalDraftTestData.JobApplicationDraft
        val body = DraftBody("saving a draft's body...")
        val expectedDraftWrapper = expectDraftWrapperReturns(
            draft.body,
            draft.sender,
            draft.body,
            messageId = messageId.toLocalMessageId()
        )
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.setBody(body.value) } returns VoidDraftSaveSendResult.Ok
        coEvery { expectedDraftWrapper.save() } returns VoidDraftSaveSendResult.Ok

        // When
        val actual = dataSource.saveBody(body)

        // Then
        assertEquals(actual, Unit.right())
    }

    @Test
    fun `save body returns error when rust draft wrapper call fails`() = runTest {
        // Given
        val draft = LocalDraftTestData.JobApplicationDraft
        val body = DraftBody("saving a draft's body...")
        val expectedDraftWrapper = expectDraftWrapperReturns(draft.body, draft.sender, draft.body)
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { expectedDraftWrapper.setBody(body.value) } returns VoidDraftSaveSendResult.Error(
            DraftSaveSendError.Reason(DraftSaveSendErrorReason.MessageIsNotADraft)
        )
        val expected = DataError.Local.SendDraftError.AlreadySent

        // When
        val actual = dataSource.saveBody(body)

        // Then
        assertEquals(actual, expected.left())
    }

    @Test
    fun `returns success when send draft succeeds`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = LocalMessageIdSample.AugWeatherForecast
        val expectedDraftWrapper = expectDraftWrapperReturns(
            messageId = messageId
        )
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper
        coEvery { userSessionRepository.observePrimaryUserId() } returns flowOf(userId)
        coEvery {
            enqueuer.enqueueUniqueWork<SendingStatusWorker>(
                userId = userId,
                workerId = SendingStatusWorker.id(userId, messageId.toMessageId()),
                params = SendingStatusWorker.params(userId, messageId.toMessageId()),
                backoffCriteria = Enqueuer.BackoffCriteria.DefaultLinear,
                initialDelay = InitialDelayForSendingStatusWorker
            )
        } returns Unit

        // When
        val actual = dataSource.send()

        // Then
        assertEquals(Unit.right(), actual)
        coVerify {
            enqueuer.enqueueUniqueWork<SendingStatusWorker>(
                userId = userId,
                workerId = SendingStatusWorker.id(userId, messageId.toMessageId()),
                params = SendingStatusWorker.params(userId, messageId.toMessageId()),
                backoffCriteria = Enqueuer.BackoffCriteria.DefaultLinear,
                initialDelay = InitialDelayForSendingStatusWorker
            )
        }
    }

    @Test
    fun `returns error when send draft fails`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = LocalMessageIdSample.AugWeatherForecast
        val expectedError = DataError.Local.SendDraftError.AttachmentsError

        val expectedDraftWrapper = expectDraftWrapperReturns(
            messageId = messageId,
            sendResult = VoidDraftSaveSendResult.Error(
                DraftSaveSendError.Reason(
                    DraftSaveSendErrorReason.AttachmentUpload
                )
            )
        )
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper

        coEvery { userSessionRepository.observePrimaryUserId() } returns flowOf(userId)

        // When
        val actual = dataSource.send()

        // Then
        assertEquals(expectedError.left(), actual)
        coVerify(exactly = 0) {
            enqueuer.enqueueUniqueWork<SendingStatusWorker>(
                any(), any(), any(), any(), any()
            )
        }
    }

    @Test
    fun `undoSend returns error when session is null`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageIdSample.LocalDraft
        val expected = DataError.Local.Unknown
        coEvery { userSessionRepository.getUserSession(userId) } returns null

        // When
        val actual = dataSource.undoSend(userId, messageId)

        // Then
        assertEquals(expected.left(), actual)
    }

    @Test
    fun `undoSend returns error when rustDraftUndoSend fails`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageId("110")
        val expectedError = DataError.Local.Unknown
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { rustDraftUndoSend(mockUserSession, messageId.toLocalMessageId()) } returns expectedError.left()

        // When
        val actual = dataSource.undoSend(userId, messageId)

        // Then
        assertEquals(expectedError.left(), actual)
    }

    @Test
    fun `undoSend cancels sending status worker when successful`() = runTest {
        // Given
        val userId = UserIdSample.Primary
        val messageId = MessageId("110")
        coEvery { userSessionRepository.getUserSession(userId) } returns mockUserSession
        coEvery { rustDraftUndoSend(mockUserSession, messageId.toLocalMessageId()) } returns Unit.right()
        coEvery { enqueuer.cancelWork(SendingStatusWorker.id(userId, messageId)) } just Runs

        // When
        val actual = dataSource.undoSend(userId, messageId)

        // Then
        assertEquals(Unit.right(), actual)
        coVerify { enqueuer.cancelWork(SendingStatusWorker.id(userId, messageId)) }
    }

    @Test
    fun `update To recipients adds and removes recipients as needed`() = runTest {
        // Given
        val bob = RecipientSample.Bob // will be removed
        val john = RecipientSample.John // will be added
        val alice = RecipientSample.Alice // unchanged
        val updatedRecipients = listOf(john, alice)
        val currentRecipients = listOf(
            LocalComposerRecipientTestData.Alice, LocalComposerRecipientTestData.Bob
        )

        val toRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            toRecipientsWrapper = toRecipientsWrapperMock
        )
        coEvery { toRecipientsWrapperMock.recipients() } returns currentRecipients
        coEvery { toRecipientsWrapperMock.addSingleRecipient(any()) } returns Unit.right()
        coEvery { toRecipientsWrapperMock.removeSingleRecipient(any()) } returns Unit.right()
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper

        // When
        dataSource.updateToRecipients(updatedRecipients)

        // Then
        verifyOrder {
            toRecipientsWrapperMock.addSingleRecipient(john.toSingleRecipientEntry())
            toRecipientsWrapperMock.removeSingleRecipient(bob.toSingleRecipientEntry())
        }
    }

    @Test
    fun `update Cc recipients adds and removes recipients as needed`() = runTest {
        // Given
        val bob = RecipientSample.Bob // will be removed
        val john = RecipientSample.John // will be added
        val alice = RecipientSample.Alice // unchanged
        val updatedRecipients = listOf(john, alice)
        val currentRecipients = listOf(
            LocalComposerRecipientTestData.Alice, LocalComposerRecipientTestData.Bob
        )

        val ccRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            ccRecipientsWrapper = ccRecipientsWrapperMock
        )
        coEvery { ccRecipientsWrapperMock.recipients() } returns currentRecipients
        coEvery { ccRecipientsWrapperMock.addSingleRecipient(any()) } returns Unit.right()
        coEvery { ccRecipientsWrapperMock.removeSingleRecipient(any()) } returns Unit.right()
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper

        // When
        dataSource.updateCcRecipients(updatedRecipients)

        // Then
        verifyOrder {
            ccRecipientsWrapperMock.addSingleRecipient(john.toSingleRecipientEntry())
            ccRecipientsWrapperMock.removeSingleRecipient(bob.toSingleRecipientEntry())
        }
    }

    @Test
    fun `update Bcc recipients adds and removes recipients as needed`() = runTest {
        // Given
        val bob = RecipientSample.Bob // will be removed
        val john = RecipientSample.John // will be added
        val alice = RecipientSample.Alice // unchanged
        val updatedRecipients = listOf(john, alice)
        val currentRecipients = listOf(
            LocalComposerRecipientTestData.Alice, LocalComposerRecipientTestData.Bob
        )

        val bccRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            bccRecipientsWrapper = bccRecipientsWrapperMock
        )
        coEvery { bccRecipientsWrapperMock.recipients() } returns currentRecipients
        coEvery { bccRecipientsWrapperMock.addSingleRecipient(any()) } returns Unit.right()
        coEvery { bccRecipientsWrapperMock.removeSingleRecipient(any()) } returns Unit.right()
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper

        // When
        dataSource.updateBccRecipients(updatedRecipients)

        // Then
        verifyOrder {
            bccRecipientsWrapperMock.addSingleRecipient(john.toSingleRecipientEntry())
            bccRecipientsWrapperMock.removeSingleRecipient(bob.toSingleRecipientEntry())
        }
    }

    @Test
    fun `update recipients compares recipients by address`() = runTest {
        // Given
        // Due to some contact-suggestions related features not done yet, it can happen that the contact
        // we pass from UI has a different name than the one that's saved in rust (ie. in reply case where
        // rust save the contact before UI passes it); To keep this working, we compare contacts by address.
        val johnNameless = RecipientSample.John.copy(name = "") // won't be (re) added
        val updatedRecipients = listOf(johnNameless)
        val currentRecipients = listOf(
            LocalComposerRecipientTestData.John, LocalComposerRecipientTestData.Bob
        )

        val bccRecipientsWrapperMock = mockk<ComposerRecipientListWrapper>()
        val expectedDraftWrapper = expectDraftWrapperReturns(
            bccRecipientsWrapper = bccRecipientsWrapperMock
        )
        coEvery { bccRecipientsWrapperMock.recipients() } returns currentRecipients
        coEvery { bccRecipientsWrapperMock.addSingleRecipient(any()) } returns Unit.right()
        coEvery { bccRecipientsWrapperMock.removeSingleRecipient(any()) } returns Unit.right()
        dataSource.draftWrapperMutableStateFlow.value = expectedDraftWrapper

        // When
        dataSource.updateBccRecipients(updatedRecipients)

        // Then
        coVerify(exactly = 0) {
            bccRecipientsWrapperMock.addSingleRecipient(johnNameless.toSingleRecipientEntry())
        }
    }

    private fun expectDraftWrapperReturns(
        subject: String = "",
        sender: String = "",
        body: String = "",
        toRecipientsWrapper: ComposerRecipientListWrapper = mockk(),
        ccRecipientsWrapper: ComposerRecipientListWrapper = mockk(),
        bccRecipientsWrapper: ComposerRecipientListWrapper = mockk(),
        messageId: LocalMessageId = LocalMessageIdSample.AugWeatherForecast,
        sendResult: VoidDraftSaveSendResult = VoidDraftSaveSendResult.Ok
    ) = mockk<DraftWrapper> {
        every { subject() } returns subject
        every { sender() } returns sender
        every { body() } returns body
        every { recipientsTo() } returns toRecipientsWrapper
        every { recipientsCc() } returns ccRecipientsWrapper
        every { recipientsBcc() } returns bccRecipientsWrapper
        coEvery { send() } returns sendResult
        coEvery { messageId() } returns DraftMessageIdResult.Ok(messageId)
    }

}
